// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.5
//   protoc               v3.12.4
// source: libs/proto/user/user-service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "user";

/** Authentication Messages */
export interface RegisterUserRequest {
  email: string;
  username?: string | undefined;
  password: string;
}

export interface RegisterUserResponse {
  userId?: string | undefined;
  message: string;
}

export interface AuthenticateUserRequest {
  email: string;
  password: string;
}

export interface AuthenticateUserResponse {
  sessionToken: string;
}

export interface LogoutUserRequest {
  sessionToken: string;
}

export interface LogoutUserResponse {
  message: string;
}

export interface RenewSessionRequest {
  sessionToken: string;
}

export interface RenewSessionResponse {
  newSessionToken: string;
  expiresAt: string;
}

export interface RevokeSessionRequest {
  sessionToken: string;
  reason: string;
}

export interface RevokeSessionResponse {
  message: string;
}

/** Password Management Messages */
export interface SendResetPasswordRequest {
  email: string;
}

export interface SendResetPasswordResponse {
  message: string;
}

export interface ResetPasswordRequest {
  resetToken: string;
  newPassword: string;
}

export interface ResetPasswordResponse {
  message: string;
}

export interface UpdatePasswordRequest {
  userId: string;
  oldPassword: string;
  newPassword: string;
}

export interface UpdatePasswordResponse {
  message: string;
}

/** Email Verification Messages */
export interface SendEmailVerificationRequest {
  email: string;
}

export interface SendEmailVerificationResponse {
  message: string;
}

export interface VerifyEmailRequest {
  verificationToken: string;
}

export interface VerifyEmailResponse {
  message: string;
}

/** Profile Management Messages */
export interface GetUserProfileRequest {
  userId: string;
}

export interface GetUserProfileResponse {
  userId: string;
  firstName: string;
  lastName: string;
  avatarUrl?: string | undefined;
  bio?: string | undefined;
  address?: Address | undefined;
  preferences: Preferences | undefined;
}

export interface UpdateUserProfileRequest {
  userId: string;
  firstName: string;
  lastName: string;
  bio?: string | undefined;
  address?: Address | undefined;
}

export interface UpdateUserProfileResponse {
  message: string;
}

export interface UploadProfilePictureRequest {
  userId: string;
  picture: Uint8Array;
}

export interface UploadProfilePictureResponse {
  avatarUrl: string;
}

export interface UpdateUserPreferencesRequest {
  userId: string;
  preferences: Preferences | undefined;
}

export interface UpdateUserPreferencesResponse {
  message: string;
}

/** Authorization Messages */
export interface AssignUserRoleRequest {
  userId: string;
  role: string;
}

export interface AssignUserRoleResponse {
  message: string;
}

/** Activity and History Messages */
export interface GetLoginHistoryRequest {
  userId: string;
}

export interface GetLoginHistoryResponse {
  logs: LoginHistory[];
}

export interface LoginHistory {
  loginAt: string;
  ipAddress: string;
  device: string;
  location: string;
}

export interface GetActivityLogsRequest {
  userId: string;
}

export interface GetActivityLogsResponse {
  logs: ActivityLog[];
}

export interface ActivityLog {
  action: string;
  timestamp: string;
  ipAddress: string;
  device: string;
  details: ActivityLogDetail[];
}

export interface ActivityLogDetail {
  fieldUpdated: string;
  previousValue: string;
  newValue: string;
}

/** Account Management Messages */
export interface LockAccountRequest {
  userId: string;
}

export interface LockAccountResponse {
  message: string;
}

export interface UnlockAccountRequest {
  userId: string;
}

export interface UnlockAccountResponse {
  message: string;
}

export interface DeleteAccountRequest {
  userId: string;
}

export interface DeleteAccountResponse {
  message: string;
}

/** Shared Types */
export interface Address {
  street: string;
  city: string;
  state: string;
  zipCode: string;
  country: string;
}

export interface Preferences {
  language: string;
  notifications: NotificationSettings[];
}

export interface NotificationSettings {
  channel: string;
  enabled: boolean;
}

function createBaseRegisterUserRequest(): RegisterUserRequest {
  return { email: "", username: undefined, password: "" };
}

export const RegisterUserRequest: MessageFns<RegisterUserRequest> = {
  encode(message: RegisterUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.username !== undefined) {
      writer.uint32(18).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(26).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.password = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterUserRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : undefined,
      password: isSet(object.password) ? globalThis.String(object.password) : "",
    };
  },

  toJSON(message: RegisterUserRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.username !== undefined) {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterUserRequest>, I>>(base?: I): RegisterUserRequest {
    return RegisterUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterUserRequest>, I>>(object: I): RegisterUserRequest {
    const message = createBaseRegisterUserRequest();
    message.email = object.email ?? "";
    message.username = object.username ?? undefined;
    message.password = object.password ?? "";
    return message;
  },
};

function createBaseRegisterUserResponse(): RegisterUserResponse {
  return { userId: undefined, message: "" };
}

export const RegisterUserResponse: MessageFns<RegisterUserResponse> = {
  encode(message: RegisterUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== undefined) {
      writer.uint32(10).string(message.userId);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterUserResponse {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : undefined,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: RegisterUserResponse): unknown {
    const obj: any = {};
    if (message.userId !== undefined) {
      obj.userId = message.userId;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterUserResponse>, I>>(base?: I): RegisterUserResponse {
    return RegisterUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterUserResponse>, I>>(object: I): RegisterUserResponse {
    const message = createBaseRegisterUserResponse();
    message.userId = object.userId ?? undefined;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseAuthenticateUserRequest(): AuthenticateUserRequest {
  return { email: "", password: "" };
}

export const AuthenticateUserRequest: MessageFns<AuthenticateUserRequest> = {
  encode(message: AuthenticateUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthenticateUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthenticateUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthenticateUserRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
    };
  },

  toJSON(message: AuthenticateUserRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthenticateUserRequest>, I>>(base?: I): AuthenticateUserRequest {
    return AuthenticateUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthenticateUserRequest>, I>>(object: I): AuthenticateUserRequest {
    const message = createBaseAuthenticateUserRequest();
    message.email = object.email ?? "";
    message.password = object.password ?? "";
    return message;
  },
};

function createBaseAuthenticateUserResponse(): AuthenticateUserResponse {
  return { sessionToken: "" };
}

export const AuthenticateUserResponse: MessageFns<AuthenticateUserResponse> = {
  encode(message: AuthenticateUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionToken !== "") {
      writer.uint32(10).string(message.sessionToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthenticateUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthenticateUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthenticateUserResponse {
    return { sessionToken: isSet(object.sessionToken) ? globalThis.String(object.sessionToken) : "" };
  },

  toJSON(message: AuthenticateUserResponse): unknown {
    const obj: any = {};
    if (message.sessionToken !== "") {
      obj.sessionToken = message.sessionToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthenticateUserResponse>, I>>(base?: I): AuthenticateUserResponse {
    return AuthenticateUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthenticateUserResponse>, I>>(object: I): AuthenticateUserResponse {
    const message = createBaseAuthenticateUserResponse();
    message.sessionToken = object.sessionToken ?? "";
    return message;
  },
};

function createBaseLogoutUserRequest(): LogoutUserRequest {
  return { sessionToken: "" };
}

export const LogoutUserRequest: MessageFns<LogoutUserRequest> = {
  encode(message: LogoutUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionToken !== "") {
      writer.uint32(10).string(message.sessionToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogoutUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogoutUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogoutUserRequest {
    return { sessionToken: isSet(object.sessionToken) ? globalThis.String(object.sessionToken) : "" };
  },

  toJSON(message: LogoutUserRequest): unknown {
    const obj: any = {};
    if (message.sessionToken !== "") {
      obj.sessionToken = message.sessionToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LogoutUserRequest>, I>>(base?: I): LogoutUserRequest {
    return LogoutUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogoutUserRequest>, I>>(object: I): LogoutUserRequest {
    const message = createBaseLogoutUserRequest();
    message.sessionToken = object.sessionToken ?? "";
    return message;
  },
};

function createBaseLogoutUserResponse(): LogoutUserResponse {
  return { message: "" };
}

export const LogoutUserResponse: MessageFns<LogoutUserResponse> = {
  encode(message: LogoutUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogoutUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogoutUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogoutUserResponse {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: LogoutUserResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LogoutUserResponse>, I>>(base?: I): LogoutUserResponse {
    return LogoutUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogoutUserResponse>, I>>(object: I): LogoutUserResponse {
    const message = createBaseLogoutUserResponse();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseRenewSessionRequest(): RenewSessionRequest {
  return { sessionToken: "" };
}

export const RenewSessionRequest: MessageFns<RenewSessionRequest> = {
  encode(message: RenewSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionToken !== "") {
      writer.uint32(10).string(message.sessionToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RenewSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenewSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RenewSessionRequest {
    return { sessionToken: isSet(object.sessionToken) ? globalThis.String(object.sessionToken) : "" };
  },

  toJSON(message: RenewSessionRequest): unknown {
    const obj: any = {};
    if (message.sessionToken !== "") {
      obj.sessionToken = message.sessionToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RenewSessionRequest>, I>>(base?: I): RenewSessionRequest {
    return RenewSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RenewSessionRequest>, I>>(object: I): RenewSessionRequest {
    const message = createBaseRenewSessionRequest();
    message.sessionToken = object.sessionToken ?? "";
    return message;
  },
};

function createBaseRenewSessionResponse(): RenewSessionResponse {
  return { newSessionToken: "", expiresAt: "" };
}

export const RenewSessionResponse: MessageFns<RenewSessionResponse> = {
  encode(message: RenewSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.newSessionToken !== "") {
      writer.uint32(10).string(message.newSessionToken);
    }
    if (message.expiresAt !== "") {
      writer.uint32(18).string(message.expiresAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RenewSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenewSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.newSessionToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.expiresAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RenewSessionResponse {
    return {
      newSessionToken: isSet(object.newSessionToken) ? globalThis.String(object.newSessionToken) : "",
      expiresAt: isSet(object.expiresAt) ? globalThis.String(object.expiresAt) : "",
    };
  },

  toJSON(message: RenewSessionResponse): unknown {
    const obj: any = {};
    if (message.newSessionToken !== "") {
      obj.newSessionToken = message.newSessionToken;
    }
    if (message.expiresAt !== "") {
      obj.expiresAt = message.expiresAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RenewSessionResponse>, I>>(base?: I): RenewSessionResponse {
    return RenewSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RenewSessionResponse>, I>>(object: I): RenewSessionResponse {
    const message = createBaseRenewSessionResponse();
    message.newSessionToken = object.newSessionToken ?? "";
    message.expiresAt = object.expiresAt ?? "";
    return message;
  },
};

function createBaseRevokeSessionRequest(): RevokeSessionRequest {
  return { sessionToken: "", reason: "" };
}

export const RevokeSessionRequest: MessageFns<RevokeSessionRequest> = {
  encode(message: RevokeSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionToken !== "") {
      writer.uint32(10).string(message.sessionToken);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RevokeSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevokeSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RevokeSessionRequest {
    return {
      sessionToken: isSet(object.sessionToken) ? globalThis.String(object.sessionToken) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: RevokeSessionRequest): unknown {
    const obj: any = {};
    if (message.sessionToken !== "") {
      obj.sessionToken = message.sessionToken;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RevokeSessionRequest>, I>>(base?: I): RevokeSessionRequest {
    return RevokeSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RevokeSessionRequest>, I>>(object: I): RevokeSessionRequest {
    const message = createBaseRevokeSessionRequest();
    message.sessionToken = object.sessionToken ?? "";
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseRevokeSessionResponse(): RevokeSessionResponse {
  return { message: "" };
}

export const RevokeSessionResponse: MessageFns<RevokeSessionResponse> = {
  encode(message: RevokeSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RevokeSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevokeSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RevokeSessionResponse {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: RevokeSessionResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RevokeSessionResponse>, I>>(base?: I): RevokeSessionResponse {
    return RevokeSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RevokeSessionResponse>, I>>(object: I): RevokeSessionResponse {
    const message = createBaseRevokeSessionResponse();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseSendResetPasswordRequest(): SendResetPasswordRequest {
  return { email: "" };
}

export const SendResetPasswordRequest: MessageFns<SendResetPasswordRequest> = {
  encode(message: SendResetPasswordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendResetPasswordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendResetPasswordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendResetPasswordRequest {
    return { email: isSet(object.email) ? globalThis.String(object.email) : "" };
  },

  toJSON(message: SendResetPasswordRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendResetPasswordRequest>, I>>(base?: I): SendResetPasswordRequest {
    return SendResetPasswordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendResetPasswordRequest>, I>>(object: I): SendResetPasswordRequest {
    const message = createBaseSendResetPasswordRequest();
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseSendResetPasswordResponse(): SendResetPasswordResponse {
  return { message: "" };
}

export const SendResetPasswordResponse: MessageFns<SendResetPasswordResponse> = {
  encode(message: SendResetPasswordResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendResetPasswordResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendResetPasswordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendResetPasswordResponse {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: SendResetPasswordResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendResetPasswordResponse>, I>>(base?: I): SendResetPasswordResponse {
    return SendResetPasswordResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendResetPasswordResponse>, I>>(object: I): SendResetPasswordResponse {
    const message = createBaseSendResetPasswordResponse();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseResetPasswordRequest(): ResetPasswordRequest {
  return { resetToken: "", newPassword: "" };
}

export const ResetPasswordRequest: MessageFns<ResetPasswordRequest> = {
  encode(message: ResetPasswordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resetToken !== "") {
      writer.uint32(10).string(message.resetToken);
    }
    if (message.newPassword !== "") {
      writer.uint32(18).string(message.newPassword);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResetPasswordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResetPasswordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resetToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newPassword = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResetPasswordRequest {
    return {
      resetToken: isSet(object.resetToken) ? globalThis.String(object.resetToken) : "",
      newPassword: isSet(object.newPassword) ? globalThis.String(object.newPassword) : "",
    };
  },

  toJSON(message: ResetPasswordRequest): unknown {
    const obj: any = {};
    if (message.resetToken !== "") {
      obj.resetToken = message.resetToken;
    }
    if (message.newPassword !== "") {
      obj.newPassword = message.newPassword;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResetPasswordRequest>, I>>(base?: I): ResetPasswordRequest {
    return ResetPasswordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResetPasswordRequest>, I>>(object: I): ResetPasswordRequest {
    const message = createBaseResetPasswordRequest();
    message.resetToken = object.resetToken ?? "";
    message.newPassword = object.newPassword ?? "";
    return message;
  },
};

function createBaseResetPasswordResponse(): ResetPasswordResponse {
  return { message: "" };
}

export const ResetPasswordResponse: MessageFns<ResetPasswordResponse> = {
  encode(message: ResetPasswordResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResetPasswordResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResetPasswordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResetPasswordResponse {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: ResetPasswordResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResetPasswordResponse>, I>>(base?: I): ResetPasswordResponse {
    return ResetPasswordResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResetPasswordResponse>, I>>(object: I): ResetPasswordResponse {
    const message = createBaseResetPasswordResponse();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseUpdatePasswordRequest(): UpdatePasswordRequest {
  return { userId: "", oldPassword: "", newPassword: "" };
}

export const UpdatePasswordRequest: MessageFns<UpdatePasswordRequest> = {
  encode(message: UpdatePasswordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.oldPassword !== "") {
      writer.uint32(18).string(message.oldPassword);
    }
    if (message.newPassword !== "") {
      writer.uint32(26).string(message.newPassword);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatePasswordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePasswordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.oldPassword = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newPassword = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdatePasswordRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      oldPassword: isSet(object.oldPassword) ? globalThis.String(object.oldPassword) : "",
      newPassword: isSet(object.newPassword) ? globalThis.String(object.newPassword) : "",
    };
  },

  toJSON(message: UpdatePasswordRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.oldPassword !== "") {
      obj.oldPassword = message.oldPassword;
    }
    if (message.newPassword !== "") {
      obj.newPassword = message.newPassword;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdatePasswordRequest>, I>>(base?: I): UpdatePasswordRequest {
    return UpdatePasswordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdatePasswordRequest>, I>>(object: I): UpdatePasswordRequest {
    const message = createBaseUpdatePasswordRequest();
    message.userId = object.userId ?? "";
    message.oldPassword = object.oldPassword ?? "";
    message.newPassword = object.newPassword ?? "";
    return message;
  },
};

function createBaseUpdatePasswordResponse(): UpdatePasswordResponse {
  return { message: "" };
}

export const UpdatePasswordResponse: MessageFns<UpdatePasswordResponse> = {
  encode(message: UpdatePasswordResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatePasswordResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePasswordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdatePasswordResponse {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: UpdatePasswordResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdatePasswordResponse>, I>>(base?: I): UpdatePasswordResponse {
    return UpdatePasswordResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdatePasswordResponse>, I>>(object: I): UpdatePasswordResponse {
    const message = createBaseUpdatePasswordResponse();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseSendEmailVerificationRequest(): SendEmailVerificationRequest {
  return { email: "" };
}

export const SendEmailVerificationRequest: MessageFns<SendEmailVerificationRequest> = {
  encode(message: SendEmailVerificationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendEmailVerificationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendEmailVerificationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendEmailVerificationRequest {
    return { email: isSet(object.email) ? globalThis.String(object.email) : "" };
  },

  toJSON(message: SendEmailVerificationRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendEmailVerificationRequest>, I>>(base?: I): SendEmailVerificationRequest {
    return SendEmailVerificationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendEmailVerificationRequest>, I>>(object: I): SendEmailVerificationRequest {
    const message = createBaseSendEmailVerificationRequest();
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseSendEmailVerificationResponse(): SendEmailVerificationResponse {
  return { message: "" };
}

export const SendEmailVerificationResponse: MessageFns<SendEmailVerificationResponse> = {
  encode(message: SendEmailVerificationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendEmailVerificationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendEmailVerificationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendEmailVerificationResponse {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: SendEmailVerificationResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendEmailVerificationResponse>, I>>(base?: I): SendEmailVerificationResponse {
    return SendEmailVerificationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendEmailVerificationResponse>, I>>(
    object: I,
  ): SendEmailVerificationResponse {
    const message = createBaseSendEmailVerificationResponse();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseVerifyEmailRequest(): VerifyEmailRequest {
  return { verificationToken: "" };
}

export const VerifyEmailRequest: MessageFns<VerifyEmailRequest> = {
  encode(message: VerifyEmailRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.verificationToken !== "") {
      writer.uint32(10).string(message.verificationToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyEmailRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyEmailRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.verificationToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyEmailRequest {
    return { verificationToken: isSet(object.verificationToken) ? globalThis.String(object.verificationToken) : "" };
  },

  toJSON(message: VerifyEmailRequest): unknown {
    const obj: any = {};
    if (message.verificationToken !== "") {
      obj.verificationToken = message.verificationToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyEmailRequest>, I>>(base?: I): VerifyEmailRequest {
    return VerifyEmailRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyEmailRequest>, I>>(object: I): VerifyEmailRequest {
    const message = createBaseVerifyEmailRequest();
    message.verificationToken = object.verificationToken ?? "";
    return message;
  },
};

function createBaseVerifyEmailResponse(): VerifyEmailResponse {
  return { message: "" };
}

export const VerifyEmailResponse: MessageFns<VerifyEmailResponse> = {
  encode(message: VerifyEmailResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyEmailResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyEmailResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyEmailResponse {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: VerifyEmailResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyEmailResponse>, I>>(base?: I): VerifyEmailResponse {
    return VerifyEmailResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyEmailResponse>, I>>(object: I): VerifyEmailResponse {
    const message = createBaseVerifyEmailResponse();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseGetUserProfileRequest(): GetUserProfileRequest {
  return { userId: "" };
}

export const GetUserProfileRequest: MessageFns<GetUserProfileRequest> = {
  encode(message: GetUserProfileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserProfileRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserProfileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserProfileRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: GetUserProfileRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserProfileRequest>, I>>(base?: I): GetUserProfileRequest {
    return GetUserProfileRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserProfileRequest>, I>>(object: I): GetUserProfileRequest {
    const message = createBaseGetUserProfileRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseGetUserProfileResponse(): GetUserProfileResponse {
  return {
    userId: "",
    firstName: "",
    lastName: "",
    avatarUrl: undefined,
    bio: undefined,
    address: undefined,
    preferences: undefined,
  };
}

export const GetUserProfileResponse: MessageFns<GetUserProfileResponse> = {
  encode(message: GetUserProfileResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.firstName !== "") {
      writer.uint32(18).string(message.firstName);
    }
    if (message.lastName !== "") {
      writer.uint32(26).string(message.lastName);
    }
    if (message.avatarUrl !== undefined) {
      writer.uint32(34).string(message.avatarUrl);
    }
    if (message.bio !== undefined) {
      writer.uint32(42).string(message.bio);
    }
    if (message.address !== undefined) {
      Address.encode(message.address, writer.uint32(50).fork()).join();
    }
    if (message.preferences !== undefined) {
      Preferences.encode(message.preferences, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserProfileResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserProfileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.lastName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.avatarUrl = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.bio = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.address = Address.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.preferences = Preferences.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserProfileResponse {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : "",
      lastName: isSet(object.lastName) ? globalThis.String(object.lastName) : "",
      avatarUrl: isSet(object.avatarUrl) ? globalThis.String(object.avatarUrl) : undefined,
      bio: isSet(object.bio) ? globalThis.String(object.bio) : undefined,
      address: isSet(object.address) ? Address.fromJSON(object.address) : undefined,
      preferences: isSet(object.preferences) ? Preferences.fromJSON(object.preferences) : undefined,
    };
  },

  toJSON(message: GetUserProfileResponse): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.firstName !== "") {
      obj.firstName = message.firstName;
    }
    if (message.lastName !== "") {
      obj.lastName = message.lastName;
    }
    if (message.avatarUrl !== undefined) {
      obj.avatarUrl = message.avatarUrl;
    }
    if (message.bio !== undefined) {
      obj.bio = message.bio;
    }
    if (message.address !== undefined) {
      obj.address = Address.toJSON(message.address);
    }
    if (message.preferences !== undefined) {
      obj.preferences = Preferences.toJSON(message.preferences);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserProfileResponse>, I>>(base?: I): GetUserProfileResponse {
    return GetUserProfileResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserProfileResponse>, I>>(object: I): GetUserProfileResponse {
    const message = createBaseGetUserProfileResponse();
    message.userId = object.userId ?? "";
    message.firstName = object.firstName ?? "";
    message.lastName = object.lastName ?? "";
    message.avatarUrl = object.avatarUrl ?? undefined;
    message.bio = object.bio ?? undefined;
    message.address = (object.address !== undefined && object.address !== null)
      ? Address.fromPartial(object.address)
      : undefined;
    message.preferences = (object.preferences !== undefined && object.preferences !== null)
      ? Preferences.fromPartial(object.preferences)
      : undefined;
    return message;
  },
};

function createBaseUpdateUserProfileRequest(): UpdateUserProfileRequest {
  return { userId: "", firstName: "", lastName: "", bio: undefined, address: undefined };
}

export const UpdateUserProfileRequest: MessageFns<UpdateUserProfileRequest> = {
  encode(message: UpdateUserProfileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.firstName !== "") {
      writer.uint32(18).string(message.firstName);
    }
    if (message.lastName !== "") {
      writer.uint32(26).string(message.lastName);
    }
    if (message.bio !== undefined) {
      writer.uint32(34).string(message.bio);
    }
    if (message.address !== undefined) {
      Address.encode(message.address, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateUserProfileRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserProfileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.lastName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bio = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.address = Address.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateUserProfileRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : "",
      lastName: isSet(object.lastName) ? globalThis.String(object.lastName) : "",
      bio: isSet(object.bio) ? globalThis.String(object.bio) : undefined,
      address: isSet(object.address) ? Address.fromJSON(object.address) : undefined,
    };
  },

  toJSON(message: UpdateUserProfileRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.firstName !== "") {
      obj.firstName = message.firstName;
    }
    if (message.lastName !== "") {
      obj.lastName = message.lastName;
    }
    if (message.bio !== undefined) {
      obj.bio = message.bio;
    }
    if (message.address !== undefined) {
      obj.address = Address.toJSON(message.address);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateUserProfileRequest>, I>>(base?: I): UpdateUserProfileRequest {
    return UpdateUserProfileRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateUserProfileRequest>, I>>(object: I): UpdateUserProfileRequest {
    const message = createBaseUpdateUserProfileRequest();
    message.userId = object.userId ?? "";
    message.firstName = object.firstName ?? "";
    message.lastName = object.lastName ?? "";
    message.bio = object.bio ?? undefined;
    message.address = (object.address !== undefined && object.address !== null)
      ? Address.fromPartial(object.address)
      : undefined;
    return message;
  },
};

function createBaseUpdateUserProfileResponse(): UpdateUserProfileResponse {
  return { message: "" };
}

export const UpdateUserProfileResponse: MessageFns<UpdateUserProfileResponse> = {
  encode(message: UpdateUserProfileResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateUserProfileResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserProfileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateUserProfileResponse {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: UpdateUserProfileResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateUserProfileResponse>, I>>(base?: I): UpdateUserProfileResponse {
    return UpdateUserProfileResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateUserProfileResponse>, I>>(object: I): UpdateUserProfileResponse {
    const message = createBaseUpdateUserProfileResponse();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseUploadProfilePictureRequest(): UploadProfilePictureRequest {
  return { userId: "", picture: new Uint8Array(0) };
}

export const UploadProfilePictureRequest: MessageFns<UploadProfilePictureRequest> = {
  encode(message: UploadProfilePictureRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.picture.length !== 0) {
      writer.uint32(18).bytes(message.picture);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadProfilePictureRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadProfilePictureRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.picture = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadProfilePictureRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      picture: isSet(object.picture) ? bytesFromBase64(object.picture) : new Uint8Array(0),
    };
  },

  toJSON(message: UploadProfilePictureRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.picture.length !== 0) {
      obj.picture = base64FromBytes(message.picture);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UploadProfilePictureRequest>, I>>(base?: I): UploadProfilePictureRequest {
    return UploadProfilePictureRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UploadProfilePictureRequest>, I>>(object: I): UploadProfilePictureRequest {
    const message = createBaseUploadProfilePictureRequest();
    message.userId = object.userId ?? "";
    message.picture = object.picture ?? new Uint8Array(0);
    return message;
  },
};

function createBaseUploadProfilePictureResponse(): UploadProfilePictureResponse {
  return { avatarUrl: "" };
}

export const UploadProfilePictureResponse: MessageFns<UploadProfilePictureResponse> = {
  encode(message: UploadProfilePictureResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.avatarUrl !== "") {
      writer.uint32(10).string(message.avatarUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadProfilePictureResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadProfilePictureResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.avatarUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadProfilePictureResponse {
    return { avatarUrl: isSet(object.avatarUrl) ? globalThis.String(object.avatarUrl) : "" };
  },

  toJSON(message: UploadProfilePictureResponse): unknown {
    const obj: any = {};
    if (message.avatarUrl !== "") {
      obj.avatarUrl = message.avatarUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UploadProfilePictureResponse>, I>>(base?: I): UploadProfilePictureResponse {
    return UploadProfilePictureResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UploadProfilePictureResponse>, I>>(object: I): UploadProfilePictureResponse {
    const message = createBaseUploadProfilePictureResponse();
    message.avatarUrl = object.avatarUrl ?? "";
    return message;
  },
};

function createBaseUpdateUserPreferencesRequest(): UpdateUserPreferencesRequest {
  return { userId: "", preferences: undefined };
}

export const UpdateUserPreferencesRequest: MessageFns<UpdateUserPreferencesRequest> = {
  encode(message: UpdateUserPreferencesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.preferences !== undefined) {
      Preferences.encode(message.preferences, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateUserPreferencesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserPreferencesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.preferences = Preferences.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateUserPreferencesRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      preferences: isSet(object.preferences) ? Preferences.fromJSON(object.preferences) : undefined,
    };
  },

  toJSON(message: UpdateUserPreferencesRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.preferences !== undefined) {
      obj.preferences = Preferences.toJSON(message.preferences);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateUserPreferencesRequest>, I>>(base?: I): UpdateUserPreferencesRequest {
    return UpdateUserPreferencesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateUserPreferencesRequest>, I>>(object: I): UpdateUserPreferencesRequest {
    const message = createBaseUpdateUserPreferencesRequest();
    message.userId = object.userId ?? "";
    message.preferences = (object.preferences !== undefined && object.preferences !== null)
      ? Preferences.fromPartial(object.preferences)
      : undefined;
    return message;
  },
};

function createBaseUpdateUserPreferencesResponse(): UpdateUserPreferencesResponse {
  return { message: "" };
}

export const UpdateUserPreferencesResponse: MessageFns<UpdateUserPreferencesResponse> = {
  encode(message: UpdateUserPreferencesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateUserPreferencesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserPreferencesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateUserPreferencesResponse {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: UpdateUserPreferencesResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateUserPreferencesResponse>, I>>(base?: I): UpdateUserPreferencesResponse {
    return UpdateUserPreferencesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateUserPreferencesResponse>, I>>(
    object: I,
  ): UpdateUserPreferencesResponse {
    const message = createBaseUpdateUserPreferencesResponse();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseAssignUserRoleRequest(): AssignUserRoleRequest {
  return { userId: "", role: "" };
}

export const AssignUserRoleRequest: MessageFns<AssignUserRoleRequest> = {
  encode(message: AssignUserRoleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.role !== "") {
      writer.uint32(18).string(message.role);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssignUserRoleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssignUserRoleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.role = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssignUserRoleRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      role: isSet(object.role) ? globalThis.String(object.role) : "",
    };
  },

  toJSON(message: AssignUserRoleRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssignUserRoleRequest>, I>>(base?: I): AssignUserRoleRequest {
    return AssignUserRoleRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssignUserRoleRequest>, I>>(object: I): AssignUserRoleRequest {
    const message = createBaseAssignUserRoleRequest();
    message.userId = object.userId ?? "";
    message.role = object.role ?? "";
    return message;
  },
};

function createBaseAssignUserRoleResponse(): AssignUserRoleResponse {
  return { message: "" };
}

export const AssignUserRoleResponse: MessageFns<AssignUserRoleResponse> = {
  encode(message: AssignUserRoleResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssignUserRoleResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssignUserRoleResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssignUserRoleResponse {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: AssignUserRoleResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssignUserRoleResponse>, I>>(base?: I): AssignUserRoleResponse {
    return AssignUserRoleResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssignUserRoleResponse>, I>>(object: I): AssignUserRoleResponse {
    const message = createBaseAssignUserRoleResponse();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseGetLoginHistoryRequest(): GetLoginHistoryRequest {
  return { userId: "" };
}

export const GetLoginHistoryRequest: MessageFns<GetLoginHistoryRequest> = {
  encode(message: GetLoginHistoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLoginHistoryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLoginHistoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLoginHistoryRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: GetLoginHistoryRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetLoginHistoryRequest>, I>>(base?: I): GetLoginHistoryRequest {
    return GetLoginHistoryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetLoginHistoryRequest>, I>>(object: I): GetLoginHistoryRequest {
    const message = createBaseGetLoginHistoryRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseGetLoginHistoryResponse(): GetLoginHistoryResponse {
  return { logs: [] };
}

export const GetLoginHistoryResponse: MessageFns<GetLoginHistoryResponse> = {
  encode(message: GetLoginHistoryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.logs) {
      LoginHistory.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLoginHistoryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLoginHistoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.logs.push(LoginHistory.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLoginHistoryResponse {
    return {
      logs: globalThis.Array.isArray(object?.logs) ? object.logs.map((e: any) => LoginHistory.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetLoginHistoryResponse): unknown {
    const obj: any = {};
    if (message.logs?.length) {
      obj.logs = message.logs.map((e) => LoginHistory.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetLoginHistoryResponse>, I>>(base?: I): GetLoginHistoryResponse {
    return GetLoginHistoryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetLoginHistoryResponse>, I>>(object: I): GetLoginHistoryResponse {
    const message = createBaseGetLoginHistoryResponse();
    message.logs = object.logs?.map((e) => LoginHistory.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLoginHistory(): LoginHistory {
  return { loginAt: "", ipAddress: "", device: "", location: "" };
}

export const LoginHistory: MessageFns<LoginHistory> = {
  encode(message: LoginHistory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.loginAt !== "") {
      writer.uint32(10).string(message.loginAt);
    }
    if (message.ipAddress !== "") {
      writer.uint32(18).string(message.ipAddress);
    }
    if (message.device !== "") {
      writer.uint32(26).string(message.device);
    }
    if (message.location !== "") {
      writer.uint32(34).string(message.location);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoginHistory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginHistory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.loginAt = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.device = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.location = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginHistory {
    return {
      loginAt: isSet(object.loginAt) ? globalThis.String(object.loginAt) : "",
      ipAddress: isSet(object.ipAddress) ? globalThis.String(object.ipAddress) : "",
      device: isSet(object.device) ? globalThis.String(object.device) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
    };
  },

  toJSON(message: LoginHistory): unknown {
    const obj: any = {};
    if (message.loginAt !== "") {
      obj.loginAt = message.loginAt;
    }
    if (message.ipAddress !== "") {
      obj.ipAddress = message.ipAddress;
    }
    if (message.device !== "") {
      obj.device = message.device;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginHistory>, I>>(base?: I): LoginHistory {
    return LoginHistory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginHistory>, I>>(object: I): LoginHistory {
    const message = createBaseLoginHistory();
    message.loginAt = object.loginAt ?? "";
    message.ipAddress = object.ipAddress ?? "";
    message.device = object.device ?? "";
    message.location = object.location ?? "";
    return message;
  },
};

function createBaseGetActivityLogsRequest(): GetActivityLogsRequest {
  return { userId: "" };
}

export const GetActivityLogsRequest: MessageFns<GetActivityLogsRequest> = {
  encode(message: GetActivityLogsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetActivityLogsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetActivityLogsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetActivityLogsRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: GetActivityLogsRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetActivityLogsRequest>, I>>(base?: I): GetActivityLogsRequest {
    return GetActivityLogsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetActivityLogsRequest>, I>>(object: I): GetActivityLogsRequest {
    const message = createBaseGetActivityLogsRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseGetActivityLogsResponse(): GetActivityLogsResponse {
  return { logs: [] };
}

export const GetActivityLogsResponse: MessageFns<GetActivityLogsResponse> = {
  encode(message: GetActivityLogsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.logs) {
      ActivityLog.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetActivityLogsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetActivityLogsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.logs.push(ActivityLog.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetActivityLogsResponse {
    return { logs: globalThis.Array.isArray(object?.logs) ? object.logs.map((e: any) => ActivityLog.fromJSON(e)) : [] };
  },

  toJSON(message: GetActivityLogsResponse): unknown {
    const obj: any = {};
    if (message.logs?.length) {
      obj.logs = message.logs.map((e) => ActivityLog.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetActivityLogsResponse>, I>>(base?: I): GetActivityLogsResponse {
    return GetActivityLogsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetActivityLogsResponse>, I>>(object: I): GetActivityLogsResponse {
    const message = createBaseGetActivityLogsResponse();
    message.logs = object.logs?.map((e) => ActivityLog.fromPartial(e)) || [];
    return message;
  },
};

function createBaseActivityLog(): ActivityLog {
  return { action: "", timestamp: "", ipAddress: "", device: "", details: [] };
}

export const ActivityLog: MessageFns<ActivityLog> = {
  encode(message: ActivityLog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.action !== "") {
      writer.uint32(10).string(message.action);
    }
    if (message.timestamp !== "") {
      writer.uint32(18).string(message.timestamp);
    }
    if (message.ipAddress !== "") {
      writer.uint32(26).string(message.ipAddress);
    }
    if (message.device !== "") {
      writer.uint32(34).string(message.device);
    }
    for (const v of message.details) {
      ActivityLogDetail.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActivityLog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActivityLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.device = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.details.push(ActivityLogDetail.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActivityLog {
    return {
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
      ipAddress: isSet(object.ipAddress) ? globalThis.String(object.ipAddress) : "",
      device: isSet(object.device) ? globalThis.String(object.device) : "",
      details: globalThis.Array.isArray(object?.details)
        ? object.details.map((e: any) => ActivityLogDetail.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ActivityLog): unknown {
    const obj: any = {};
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    if (message.ipAddress !== "") {
      obj.ipAddress = message.ipAddress;
    }
    if (message.device !== "") {
      obj.device = message.device;
    }
    if (message.details?.length) {
      obj.details = message.details.map((e) => ActivityLogDetail.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ActivityLog>, I>>(base?: I): ActivityLog {
    return ActivityLog.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ActivityLog>, I>>(object: I): ActivityLog {
    const message = createBaseActivityLog();
    message.action = object.action ?? "";
    message.timestamp = object.timestamp ?? "";
    message.ipAddress = object.ipAddress ?? "";
    message.device = object.device ?? "";
    message.details = object.details?.map((e) => ActivityLogDetail.fromPartial(e)) || [];
    return message;
  },
};

function createBaseActivityLogDetail(): ActivityLogDetail {
  return { fieldUpdated: "", previousValue: "", newValue: "" };
}

export const ActivityLogDetail: MessageFns<ActivityLogDetail> = {
  encode(message: ActivityLogDetail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fieldUpdated !== "") {
      writer.uint32(10).string(message.fieldUpdated);
    }
    if (message.previousValue !== "") {
      writer.uint32(18).string(message.previousValue);
    }
    if (message.newValue !== "") {
      writer.uint32(26).string(message.newValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActivityLogDetail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActivityLogDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fieldUpdated = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.previousValue = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newValue = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActivityLogDetail {
    return {
      fieldUpdated: isSet(object.fieldUpdated) ? globalThis.String(object.fieldUpdated) : "",
      previousValue: isSet(object.previousValue) ? globalThis.String(object.previousValue) : "",
      newValue: isSet(object.newValue) ? globalThis.String(object.newValue) : "",
    };
  },

  toJSON(message: ActivityLogDetail): unknown {
    const obj: any = {};
    if (message.fieldUpdated !== "") {
      obj.fieldUpdated = message.fieldUpdated;
    }
    if (message.previousValue !== "") {
      obj.previousValue = message.previousValue;
    }
    if (message.newValue !== "") {
      obj.newValue = message.newValue;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ActivityLogDetail>, I>>(base?: I): ActivityLogDetail {
    return ActivityLogDetail.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ActivityLogDetail>, I>>(object: I): ActivityLogDetail {
    const message = createBaseActivityLogDetail();
    message.fieldUpdated = object.fieldUpdated ?? "";
    message.previousValue = object.previousValue ?? "";
    message.newValue = object.newValue ?? "";
    return message;
  },
};

function createBaseLockAccountRequest(): LockAccountRequest {
  return { userId: "" };
}

export const LockAccountRequest: MessageFns<LockAccountRequest> = {
  encode(message: LockAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LockAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLockAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LockAccountRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: LockAccountRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LockAccountRequest>, I>>(base?: I): LockAccountRequest {
    return LockAccountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LockAccountRequest>, I>>(object: I): LockAccountRequest {
    const message = createBaseLockAccountRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseLockAccountResponse(): LockAccountResponse {
  return { message: "" };
}

export const LockAccountResponse: MessageFns<LockAccountResponse> = {
  encode(message: LockAccountResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LockAccountResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLockAccountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LockAccountResponse {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: LockAccountResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LockAccountResponse>, I>>(base?: I): LockAccountResponse {
    return LockAccountResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LockAccountResponse>, I>>(object: I): LockAccountResponse {
    const message = createBaseLockAccountResponse();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseUnlockAccountRequest(): UnlockAccountRequest {
  return { userId: "" };
}

export const UnlockAccountRequest: MessageFns<UnlockAccountRequest> = {
  encode(message: UnlockAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnlockAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnlockAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnlockAccountRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: UnlockAccountRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnlockAccountRequest>, I>>(base?: I): UnlockAccountRequest {
    return UnlockAccountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnlockAccountRequest>, I>>(object: I): UnlockAccountRequest {
    const message = createBaseUnlockAccountRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseUnlockAccountResponse(): UnlockAccountResponse {
  return { message: "" };
}

export const UnlockAccountResponse: MessageFns<UnlockAccountResponse> = {
  encode(message: UnlockAccountResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnlockAccountResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnlockAccountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnlockAccountResponse {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: UnlockAccountResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnlockAccountResponse>, I>>(base?: I): UnlockAccountResponse {
    return UnlockAccountResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnlockAccountResponse>, I>>(object: I): UnlockAccountResponse {
    const message = createBaseUnlockAccountResponse();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseDeleteAccountRequest(): DeleteAccountRequest {
  return { userId: "" };
}

export const DeleteAccountRequest: MessageFns<DeleteAccountRequest> = {
  encode(message: DeleteAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteAccountRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: DeleteAccountRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteAccountRequest>, I>>(base?: I): DeleteAccountRequest {
    return DeleteAccountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteAccountRequest>, I>>(object: I): DeleteAccountRequest {
    const message = createBaseDeleteAccountRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseDeleteAccountResponse(): DeleteAccountResponse {
  return { message: "" };
}

export const DeleteAccountResponse: MessageFns<DeleteAccountResponse> = {
  encode(message: DeleteAccountResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAccountResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAccountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteAccountResponse {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: DeleteAccountResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteAccountResponse>, I>>(base?: I): DeleteAccountResponse {
    return DeleteAccountResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteAccountResponse>, I>>(object: I): DeleteAccountResponse {
    const message = createBaseDeleteAccountResponse();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseAddress(): Address {
  return { street: "", city: "", state: "", zipCode: "", country: "" };
}

export const Address: MessageFns<Address> = {
  encode(message: Address, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.street !== "") {
      writer.uint32(10).string(message.street);
    }
    if (message.city !== "") {
      writer.uint32(18).string(message.city);
    }
    if (message.state !== "") {
      writer.uint32(26).string(message.state);
    }
    if (message.zipCode !== "") {
      writer.uint32(34).string(message.zipCode);
    }
    if (message.country !== "") {
      writer.uint32(42).string(message.country);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Address {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.street = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.city = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.state = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.zipCode = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.country = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Address {
    return {
      street: isSet(object.street) ? globalThis.String(object.street) : "",
      city: isSet(object.city) ? globalThis.String(object.city) : "",
      state: isSet(object.state) ? globalThis.String(object.state) : "",
      zipCode: isSet(object.zipCode) ? globalThis.String(object.zipCode) : "",
      country: isSet(object.country) ? globalThis.String(object.country) : "",
    };
  },

  toJSON(message: Address): unknown {
    const obj: any = {};
    if (message.street !== "") {
      obj.street = message.street;
    }
    if (message.city !== "") {
      obj.city = message.city;
    }
    if (message.state !== "") {
      obj.state = message.state;
    }
    if (message.zipCode !== "") {
      obj.zipCode = message.zipCode;
    }
    if (message.country !== "") {
      obj.country = message.country;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Address>, I>>(base?: I): Address {
    return Address.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Address>, I>>(object: I): Address {
    const message = createBaseAddress();
    message.street = object.street ?? "";
    message.city = object.city ?? "";
    message.state = object.state ?? "";
    message.zipCode = object.zipCode ?? "";
    message.country = object.country ?? "";
    return message;
  },
};

function createBasePreferences(): Preferences {
  return { language: "", notifications: [] };
}

export const Preferences: MessageFns<Preferences> = {
  encode(message: Preferences, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.language !== "") {
      writer.uint32(10).string(message.language);
    }
    for (const v of message.notifications) {
      NotificationSettings.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Preferences {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreferences();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.language = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.notifications.push(NotificationSettings.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Preferences {
    return {
      language: isSet(object.language) ? globalThis.String(object.language) : "",
      notifications: globalThis.Array.isArray(object?.notifications)
        ? object.notifications.map((e: any) => NotificationSettings.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Preferences): unknown {
    const obj: any = {};
    if (message.language !== "") {
      obj.language = message.language;
    }
    if (message.notifications?.length) {
      obj.notifications = message.notifications.map((e) => NotificationSettings.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Preferences>, I>>(base?: I): Preferences {
    return Preferences.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Preferences>, I>>(object: I): Preferences {
    const message = createBasePreferences();
    message.language = object.language ?? "";
    message.notifications = object.notifications?.map((e) => NotificationSettings.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNotificationSettings(): NotificationSettings {
  return { channel: "", enabled: false };
}

export const NotificationSettings: MessageFns<NotificationSettings> = {
  encode(message: NotificationSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channel !== "") {
      writer.uint32(10).string(message.channel);
    }
    if (message.enabled !== false) {
      writer.uint32(16).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotificationSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.channel = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotificationSettings {
    return {
      channel: isSet(object.channel) ? globalThis.String(object.channel) : "",
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
    };
  },

  toJSON(message: NotificationSettings): unknown {
    const obj: any = {};
    if (message.channel !== "") {
      obj.channel = message.channel;
    }
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NotificationSettings>, I>>(base?: I): NotificationSettings {
    return NotificationSettings.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NotificationSettings>, I>>(object: I): NotificationSettings {
    const message = createBaseNotificationSettings();
    message.channel = object.channel ?? "";
    message.enabled = object.enabled ?? false;
    return message;
  },
};

/** User Service definition */
export interface UserService {
  /** Authentication */
  RegisterUser(request: RegisterUserRequest): Promise<RegisterUserResponse>;
  AuthenticateUser(request: AuthenticateUserRequest): Promise<AuthenticateUserResponse>;
  LogoutUser(request: LogoutUserRequest): Promise<LogoutUserResponse>;
  RenewSession(request: RenewSessionRequest): Promise<RenewSessionResponse>;
  RevokeSession(request: RevokeSessionRequest): Promise<RevokeSessionResponse>;
  /** Password Management */
  SendResetPassword(request: SendResetPasswordRequest): Promise<SendResetPasswordResponse>;
  ResetPassword(request: ResetPasswordRequest): Promise<ResetPasswordResponse>;
  UpdatePassword(request: UpdatePasswordRequest): Promise<UpdatePasswordResponse>;
  /** Email Verification */
  SendEmailVerification(request: SendEmailVerificationRequest): Promise<SendEmailVerificationResponse>;
  VerifyEmail(request: VerifyEmailRequest): Promise<VerifyEmailResponse>;
  /** Profile Management */
  GetUserProfile(request: GetUserProfileRequest): Promise<GetUserProfileResponse>;
  UpdateUserProfile(request: UpdateUserProfileRequest): Promise<UpdateUserProfileResponse>;
  UploadProfilePicture(request: UploadProfilePictureRequest): Promise<UploadProfilePictureResponse>;
  UpdateUserPreferences(request: UpdateUserPreferencesRequest): Promise<UpdateUserPreferencesResponse>;
  /** Authorization */
  AssignUserRole(request: AssignUserRoleRequest): Promise<AssignUserRoleResponse>;
  /** Activity and History Tracking */
  GetLoginHistory(request: GetLoginHistoryRequest): Promise<GetLoginHistoryResponse>;
  GetActivityLogs(request: GetActivityLogsRequest): Promise<GetActivityLogsResponse>;
  /** Account Management */
  LockAccount(request: LockAccountRequest): Promise<LockAccountResponse>;
  UnlockAccount(request: UnlockAccountRequest): Promise<UnlockAccountResponse>;
  DeleteAccount(request: DeleteAccountRequest): Promise<DeleteAccountResponse>;
}

export const UserServiceServiceName = "user.UserService";
export class UserServiceClientImpl implements UserService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || UserServiceServiceName;
    this.rpc = rpc;
    this.RegisterUser = this.RegisterUser.bind(this);
    this.AuthenticateUser = this.AuthenticateUser.bind(this);
    this.LogoutUser = this.LogoutUser.bind(this);
    this.RenewSession = this.RenewSession.bind(this);
    this.RevokeSession = this.RevokeSession.bind(this);
    this.SendResetPassword = this.SendResetPassword.bind(this);
    this.ResetPassword = this.ResetPassword.bind(this);
    this.UpdatePassword = this.UpdatePassword.bind(this);
    this.SendEmailVerification = this.SendEmailVerification.bind(this);
    this.VerifyEmail = this.VerifyEmail.bind(this);
    this.GetUserProfile = this.GetUserProfile.bind(this);
    this.UpdateUserProfile = this.UpdateUserProfile.bind(this);
    this.UploadProfilePicture = this.UploadProfilePicture.bind(this);
    this.UpdateUserPreferences = this.UpdateUserPreferences.bind(this);
    this.AssignUserRole = this.AssignUserRole.bind(this);
    this.GetLoginHistory = this.GetLoginHistory.bind(this);
    this.GetActivityLogs = this.GetActivityLogs.bind(this);
    this.LockAccount = this.LockAccount.bind(this);
    this.UnlockAccount = this.UnlockAccount.bind(this);
    this.DeleteAccount = this.DeleteAccount.bind(this);
  }
  RegisterUser(request: RegisterUserRequest): Promise<RegisterUserResponse> {
    const data = RegisterUserRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RegisterUser", data);
    return promise.then((data) => RegisterUserResponse.decode(new BinaryReader(data)));
  }

  AuthenticateUser(request: AuthenticateUserRequest): Promise<AuthenticateUserResponse> {
    const data = AuthenticateUserRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AuthenticateUser", data);
    return promise.then((data) => AuthenticateUserResponse.decode(new BinaryReader(data)));
  }

  LogoutUser(request: LogoutUserRequest): Promise<LogoutUserResponse> {
    const data = LogoutUserRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "LogoutUser", data);
    return promise.then((data) => LogoutUserResponse.decode(new BinaryReader(data)));
  }

  RenewSession(request: RenewSessionRequest): Promise<RenewSessionResponse> {
    const data = RenewSessionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RenewSession", data);
    return promise.then((data) => RenewSessionResponse.decode(new BinaryReader(data)));
  }

  RevokeSession(request: RevokeSessionRequest): Promise<RevokeSessionResponse> {
    const data = RevokeSessionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RevokeSession", data);
    return promise.then((data) => RevokeSessionResponse.decode(new BinaryReader(data)));
  }

  SendResetPassword(request: SendResetPasswordRequest): Promise<SendResetPasswordResponse> {
    const data = SendResetPasswordRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SendResetPassword", data);
    return promise.then((data) => SendResetPasswordResponse.decode(new BinaryReader(data)));
  }

  ResetPassword(request: ResetPasswordRequest): Promise<ResetPasswordResponse> {
    const data = ResetPasswordRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ResetPassword", data);
    return promise.then((data) => ResetPasswordResponse.decode(new BinaryReader(data)));
  }

  UpdatePassword(request: UpdatePasswordRequest): Promise<UpdatePasswordResponse> {
    const data = UpdatePasswordRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdatePassword", data);
    return promise.then((data) => UpdatePasswordResponse.decode(new BinaryReader(data)));
  }

  SendEmailVerification(request: SendEmailVerificationRequest): Promise<SendEmailVerificationResponse> {
    const data = SendEmailVerificationRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SendEmailVerification", data);
    return promise.then((data) => SendEmailVerificationResponse.decode(new BinaryReader(data)));
  }

  VerifyEmail(request: VerifyEmailRequest): Promise<VerifyEmailResponse> {
    const data = VerifyEmailRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "VerifyEmail", data);
    return promise.then((data) => VerifyEmailResponse.decode(new BinaryReader(data)));
  }

  GetUserProfile(request: GetUserProfileRequest): Promise<GetUserProfileResponse> {
    const data = GetUserProfileRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetUserProfile", data);
    return promise.then((data) => GetUserProfileResponse.decode(new BinaryReader(data)));
  }

  UpdateUserProfile(request: UpdateUserProfileRequest): Promise<UpdateUserProfileResponse> {
    const data = UpdateUserProfileRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateUserProfile", data);
    return promise.then((data) => UpdateUserProfileResponse.decode(new BinaryReader(data)));
  }

  UploadProfilePicture(request: UploadProfilePictureRequest): Promise<UploadProfilePictureResponse> {
    const data = UploadProfilePictureRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UploadProfilePicture", data);
    return promise.then((data) => UploadProfilePictureResponse.decode(new BinaryReader(data)));
  }

  UpdateUserPreferences(request: UpdateUserPreferencesRequest): Promise<UpdateUserPreferencesResponse> {
    const data = UpdateUserPreferencesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateUserPreferences", data);
    return promise.then((data) => UpdateUserPreferencesResponse.decode(new BinaryReader(data)));
  }

  AssignUserRole(request: AssignUserRoleRequest): Promise<AssignUserRoleResponse> {
    const data = AssignUserRoleRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AssignUserRole", data);
    return promise.then((data) => AssignUserRoleResponse.decode(new BinaryReader(data)));
  }

  GetLoginHistory(request: GetLoginHistoryRequest): Promise<GetLoginHistoryResponse> {
    const data = GetLoginHistoryRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetLoginHistory", data);
    return promise.then((data) => GetLoginHistoryResponse.decode(new BinaryReader(data)));
  }

  GetActivityLogs(request: GetActivityLogsRequest): Promise<GetActivityLogsResponse> {
    const data = GetActivityLogsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetActivityLogs", data);
    return promise.then((data) => GetActivityLogsResponse.decode(new BinaryReader(data)));
  }

  LockAccount(request: LockAccountRequest): Promise<LockAccountResponse> {
    const data = LockAccountRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "LockAccount", data);
    return promise.then((data) => LockAccountResponse.decode(new BinaryReader(data)));
  }

  UnlockAccount(request: UnlockAccountRequest): Promise<UnlockAccountResponse> {
    const data = UnlockAccountRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UnlockAccount", data);
    return promise.then((data) => UnlockAccountResponse.decode(new BinaryReader(data)));
  }

  DeleteAccount(request: DeleteAccountRequest): Promise<DeleteAccountResponse> {
    const data = DeleteAccountRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteAccount", data);
    return promise.then((data) => DeleteAccountResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
